"use strict";(self.webpackChunkgraphql_kotlin_docs=self.webpackChunkgraphql_kotlin_docs||[]).push([[674],{27492:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>p,contentTitle:()=>d,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var n=i(87462),a=i(63366),r=(i(67294),i(3905)),l=(i(95657),["components"]),o={id:"federated-directives",title:"Federated Directives"},d=void 0,s={unversionedId:"schema-generator/federation/federated-directives",id:"schema-generator/federation/federated-directives",title:"Federated Directives",description:"graphql-kotlin supports a number of directives that can be used to annotate a schema and direct certain behaviors.",source:"@site/docs/schema-generator/federation/federated-directives.md",sourceDirName:"schema-generator/federation",slug:"/schema-generator/federation/federated-directives",permalink:"/graphql-kotlin/docs/7.x.x/schema-generator/federation/federated-directives",draft:!1,editUrl:"https://github.com/ExpediaGroup/graphql-kotlin/tree/master/website/docs/schema-generator/federation/federated-directives.md",tags:[],version:"current",lastUpdatedBy:"Samuel Vazquez",lastUpdatedAt:1685659104,formattedLastUpdatedAt:"Jun 1, 2023",frontMatter:{id:"federated-directives",title:"Federated Directives"},sidebar:"docs",previous:{title:"Federated Schemas",permalink:"/graphql-kotlin/docs/7.x.x/schema-generator/federation/federated-schemas"},next:{title:"Federated Type Resolution",permalink:"/graphql-kotlin/docs/7.x.x/schema-generator/federation/type-resolution"}},p={},c=[{value:"<code>@composeDirective</code> directive",id:"composedirective-directive",level:2},{value:"<code>@contact</code> directive",id:"contact-directive",level:2},{value:"Example usage on the schema class:",id:"example-usage-on-the-schema-class",level:4},{value:"<code>@extends</code> directive",id:"extends-directive",level:2},{value:"Example",id:"example",level:4},{value:"<code>@external</code> directive",id:"external-directive",level:2},{value:"Example",id:"example-1",level:4},{value:"<code>@inaccessible</code> directive",id:"inaccessible-directive",level:2},{value:"Example",id:"example-2",level:4},{value:"<code>@interfaceObject</code> directive",id:"interfaceobject-directive",level:2},{value:"<code>@key</code> directive",id:"key-directive",level:2},{value:"Basic Example",id:"basic-example",level:4},{value:"Referencing External Entities",id:"referencing-external-entities",level:4},{value:"<code>@link</code> directive",id:"link-directive",level:2},{value:"<code>@override</code> directive",id:"override-directive",level:2},{value:"Example",id:"example-3",level:4},{value:"<code>@provides</code> directive",id:"provides-directive",level:2},{value:"Example 1:",id:"example-1-1",level:4},{value:"Example 2:",id:"example-2-1",level:4},{value:"<code>@requires</code> directive",id:"requires-directive",level:2},{value:"Example",id:"example-4",level:4},{value:"<code>@shareable</code> directive",id:"shareable-directive",level:2},{value:"Example",id:"example-5",level:4},{value:"<code>@tag</code> directive",id:"tag-directive",level:2},{value:"Example",id:"example-6",level:4}],m={toc:c},u="wrapper";function h(e){var t=e.components,i=(0,a.Z)(e,l);return(0,r.kt)(u,(0,n.Z)({},m,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"graphql-kotlin")," supports a number of directives that can be used to annotate a schema and direct certain behaviors."),(0,r.kt)("p",null,"For more details, see the ",(0,r.kt)("a",{parentName:"p",href:"https://www.apollographql.com/docs/federation/federation-spec/"},"Apollo Federation Specification"),"."),(0,r.kt)("h2",{id:"composedirective-directive"},(0,r.kt)("inlineCode",{parentName:"h2"},"@composeDirective")," directive"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"directive @composeDirective(name: String!) repeatable on SCHEMA\n")),(0,r.kt)("p",null,"By default, Supergraph schema excludes all custom directives. The ",(0,r.kt)("inlineCode",{parentName:"p"},"@composeDirective")," is used to specify custom directives that should be exposed in the Supergraph schema."),(0,r.kt)("p",null,"In order to use composed directive, you subgraph needs to"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"contain your custom directive definition"),(0,r.kt)("li",{parentName:"ol"},"import your custom directive from a corresponding link spec"),(0,r.kt)("li",{parentName:"ol"},"apply ",(0,r.kt)("inlineCode",{parentName:"li"},"@composeDirective")," with custom directive name on your schema")),(0,r.kt)("p",null,"Example:\nGiven ",(0,r.kt)("inlineCode",{parentName:"p"},"@custom")," directive we can preserve it in the Supergraph schema"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'// 1. directive definition\n@GraphQLDirective(name = "custom", locations = [Introspection.DirectiveLocation.FIELD_DEFINITION])\nannotation class CustomDirective\n\n@LinkDirective(url = "https://myspecs.dev/myCustomDirective/v1.0", import = ["@custom"]) // 2. import custom directive from a spec\n@ComposeDirective(name = "custom") // 3. apply @composeDirective to preserve it in the schema\nclass CustomSchema\n\nclass SimpleQuery {\n  @CustomDirective\n  fun helloWorld(): String = "Hello World"\n}\n')),(0,r.kt)("p",null,"it will generate following schema"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'schema\n@composeDirective(name: "@custom")\n@link(import : ["@custom"], url: "https://myspecs.dev/myCustomDirective/v1.0")\n@link(import : ["@composeDirective", "@extends", "@external", "@inaccessible", "@interfaceObject", "@key", "@override", "@provides", "@requires", "@shareable", "@tag", "FieldSet"], url : "https://specs.apollo.dev/federation/v2.3")\n{\n   query: Query\n}\n\ndirective @custom on FIELD_DEFINITION\n\ntype Query {\n  helloWorld: String! @custom\n}\n')),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"https://www.apollographql.com/docs/federation/federated-types/federated-directives/#composedirective"},"@composeDirective definition")," for more information."),(0,r.kt)("h2",{id:"contact-directive"},(0,r.kt)("inlineCode",{parentName:"h2"},"@contact")," directive"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'directive @contact(\n  "Contact title of the subgraph owner"\n  name: String!\n  "URL where the subgraph\'s owner can be reached"\n  url: String\n  "Other relevant notes can be included here; supports markdown links"\n  description: String\n) on SCHEMA\n')),(0,r.kt)("p",null,"Contact schema directive can be used to provide team contact information to your subgraph schema. This information is automatically parsed and displayed by Apollo Studio.\nSee ",(0,r.kt)("a",{parentName:"p",href:"https://www.apollographql.com/docs/studio/federated-graphs/#subgraph-contact-info"},"Subgraph Contact Information")," for additional details."),(0,r.kt)("h4",{id:"example-usage-on-the-schema-class"},"Example usage on the schema class:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'@ContactDirective(\n  name = "My Team Name",\n  url = "https://myteam.slack.com/archives/teams-chat-room-url",\n  description = "send urgent issues to [#oncall](https://yourteam.slack.com/archives/oncall)."\n)\nclass MySchema\n')),(0,r.kt)("p",null,"will generate"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'schema @contact(description : "send urgent issues to [#oncall](https://yourteam.slack.com/archives/oncall).", name : "My Team Name", url : "https://myteam.slack.com/archives/teams-chat-room-url"){\n  query: Query\n}\n')),(0,r.kt)("h2",{id:"extends-directive"},(0,r.kt)("inlineCode",{parentName:"h2"},"@extends")," directive"),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"@extends")," directive is deprecated"),". Federation v2 no longer requires ",(0,r.kt)("inlineCode",{parentName:"p"},"@extends")," directive due to the smart entity type\nmerging. All usage of ",(0,r.kt)("inlineCode",{parentName:"p"},"@extends")," directive should be removed from your Federation v2 schemas.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"directive @extends on OBJECT | INTERFACE\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"@extends")," directive is used to represent type extensions in the schema. Native type extensions are currently\nunsupported by the ",(0,r.kt)("inlineCode",{parentName:"p"},"graphql-kotlin")," libraries. Federated extended types should have corresponding ",(0,r.kt)("inlineCode",{parentName:"p"},"@key")," directive\ndefined that specifies primary key required to fetch the underlying object."),(0,r.kt)("h4",{id:"example"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'@KeyDirective(FieldSet("id"))\n@ExtendsDirective\nclass Product(@ExternalDirective val id: String) {\n   fun newFunctionality(): String = "whatever"\n}\n')),(0,r.kt)("p",null,"will generate"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'type Product @key(fields : "id") @extends {\n  id: String! @external\n  newFunctionality: String!\n}\n')),(0,r.kt)("h2",{id:"external-directive"},(0,r.kt)("inlineCode",{parentName:"h2"},"@external")," directive"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"# federation v1 definition\ndirective @external on FIELD_DEFINITION\n\n# federation v2 definition\ndirective @external on OBJECT | FIELD_DEFINITION\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"@external")," directive is used to mark a field as owned by another service. This allows service A to use fields from\nservice B while also knowing at runtime the types of that field. All the external fields should either be referenced from\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"@key"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"@requires")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"@provides")," directives field sets."),(0,r.kt)("p",null,"Due to the smart merging of entity types, Federation v2 no longer requires ",(0,r.kt)("inlineCode",{parentName:"p"},"@external")," directive on ",(0,r.kt)("inlineCode",{parentName:"p"},"@key")," fields and can\nbe safely omitted from the schema. ",(0,r.kt)("inlineCode",{parentName:"p"},"@external")," directive is only required on fields referenced by the ",(0,r.kt)("inlineCode",{parentName:"p"},"@requires")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"@provides")," directive."),(0,r.kt)("h4",{id:"example-1"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'@KeyDirective(FieldSet("id"))\nclass Product(val id: String) {\n  @ExternalDirective\n  var externalField: String by Delegates.notNull()\n\n  @RequiresDirective(FieldSet("externalField"))\n  fun newFunctionality(): String { ... }\n}\n')),(0,r.kt)("p",null,"will generate"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'type Product @key(fields : "id") {\n  externalField: String! @external\n  id: String!\n  newFunctionality: String!\n}\n')),(0,r.kt)("h2",{id:"inaccessible-directive"},(0,r.kt)("inlineCode",{parentName:"h2"},"@inaccessible")," directive"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Only available in Federation v2.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"directive @inaccessible on FIELD_DEFINITION\n    | OBJECT\n    | INTERFACE\n    | UNION\n    | ENUM\n    | ENUM_VALUE\n    | SCALAR\n    | INPUT_OBJECT\n    | INPUT_FIELD_DEFINITION\n    | ARGUMENT_DEFINITION\n")),(0,r.kt)("p",null,"Inaccessible directive marks location within schema as inaccessible from the GraphQL Gateway. While ",(0,r.kt)("inlineCode",{parentName:"p"},"@inaccessible")," fields are not exposed by the gateway to the clients,\nthey are still available for query plans and can be referenced from ",(0,r.kt)("inlineCode",{parentName:"p"},"@key")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"@requires")," directives. This allows you to not expose sensitive fields to your clients but\nstill make them available for computations. Inaccessible can also be used to incrementally add schema elements (e.g. fields) to multiple subgraphs without breaking composition."),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"https://specs.apollo.dev/inaccessible/v0.2"},"@inaccessible specification")," for additional details."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Location within schema will be inaccessible from the GraphQL Gateway as long as ",(0,r.kt)("strong",{parentName:"p"},"ANY")," of the subgraphs marks that location as ",(0,r.kt)("inlineCode",{parentName:"p"},"@inacessible"),".")),(0,r.kt)("h4",{id:"example-2"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"class Product(\n  val id: String,\n  @InaccessibleDirective\n  val secret: String\n)\n")),(0,r.kt)("p",null,"will be generated by the subgraph as"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"type Product {\n  id: String!\n  secret: String! @inaccessible\n}\n")),(0,r.kt)("p",null,"but will be exposed on the GraphQL Gateway as"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"type Product {\n  id: String!\n}\n")),(0,r.kt)("h2",{id:"interfaceobject-directive"},(0,r.kt)("inlineCode",{parentName:"h2"},"@interfaceObject")," directive"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Only available in Federation v2.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"directive @interfaceObject on OBJECT\n")),(0,r.kt)("p",null,"This directive provides meta information to the router that this entity type defined within this subgraph is an interface in the supergraph. This allows you to extend functionality\nof an interface across the supergraph without having to implement (or even be aware of) all its implementing types."),(0,r.kt)("p",null,"Example:\nGiven an interface that is defined somewhere in our supergraph"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'interface Product @key(fields: "id") {\n  id: ID!\n  description: String\n}\n\ntype Book implements Product @key(fields: "id") {\n  id: ID!\n  description: String\n  pages: Int!\n}\n\ntype Movie implements Product @key(fields: "id") {\n  id: ID!\n  description: String\n  duration: Int!\n}\n')),(0,r.kt)("p",null,"We can extend ",(0,r.kt)("inlineCode",{parentName:"p"},"Product")," entity in our subgraph and a new field directly to it. This will result in making this new field available to ALL implementing types."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'@InterfaceObjectDirective\n@KeyDirective(fields = FieldSet("id"))\ndata class Product(val id: ID) {\n    fun reviews(): List<Review> = TODO()\n}\n')),(0,r.kt)("p",null,"Which generates the following subgraph schema"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'type Product @key(fields: "id") @interfaceObject {\n  id: ID!\n  reviews: [Review!]!\n}\n')),(0,r.kt)("h2",{id:"key-directive"},(0,r.kt)("inlineCode",{parentName:"h2"},"@key")," directive"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"# federation v1 definition\ndirective @key(fields: _FieldSet!) repeatable on OBJECT | INTERFACE\n\n# federation v2 definition\ndirective @key(fields: FieldSet!, resolvable: Boolean = true) repeatable on OBJECT | INTERFACE\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"@key")," directive is used to indicate a combination of fields that can be used to uniquely identify and fetch an\nobject or interface. The specified field set can represent single field (e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},'"id"'),"), multiple fields (e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},'"id name"'),") or\nnested selection sets (e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},'"id user { name }"'),"). Multiple keys can be specified on a target type."),(0,r.kt)("p",null,"Key directives should be specified on all entities (objects that can resolve its fields across multiple subgraphs). Key\nfields specified in the directive field set should correspond to a valid field on the underlying GraphQL interface/object."),(0,r.kt)("h4",{id:"basic-example"},"Basic Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'@KeyDirective(FieldSet("id"))\n@KeyDirective(FieldSet("upc"))\nclass Product(val id: String, val upc: String, val name: String)\n')),(0,r.kt)("p",null,"will generate"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'type Product @key(fields: "id") @key(fields: "upc") {\n  id: String!\n  name: String!\n  upc: String!\n}\n')),(0,r.kt)("h4",{id:"referencing-external-entities"},"Referencing External Entities"),(0,r.kt)("p",null,"Entity types can be referenced from other subgraphs without contributing any additional fields, i.e. we can update type within our schema with a reference to a federated type. In order to generate\na valid schema, we need to define ",(0,r.kt)("strong",{parentName:"p"},"stub")," for federated entity that contains only key fields and also mark it as not resolvable within our subgraph. For example, if we have ",(0,r.kt)("inlineCode",{parentName:"p"},"Review")," entity defined\nin our supergraph, we can reference it in our product schema using following code"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'@KeyDirective(fields = FieldSet("id"))\nclass Product(val id: String, val name: String, val reviews: List<Review>)\n\n// review stub referencing just the key fields\n@KeyDirective(fields = FieldSet("id"), resolvable = false)\nclass Review(val id: String)\n')),(0,r.kt)("p",null,"which will generate"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'type Product @key(fields: "id") {\n  id: String!\n  name: String!\n  reviews: [Review!]!\n}\n\ntype Review @key(fields: "id", resolvable: false) {\n  id: String!\n}\n')),(0,r.kt)("p",null,"This allows end users to query GraphQL Gateway for any product review fields and they will be resolved by calling the appropriate subgraph."),(0,r.kt)("h2",{id:"link-directive"},(0,r.kt)("inlineCode",{parentName:"h2"},"@link")," directive"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Only available in Federation v2.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"directive @link(url: String!, import: [String]) repeatable on SCHEMA\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"@link")," directive links definitions within the document to external schemas. See ",(0,r.kt)("a",{parentName:"p",href:"https://specs.apollo.dev/link/v1.0"},"@link specification")," for details."),(0,r.kt)("p",null,"External schemas are identified by their ",(0,r.kt)("inlineCode",{parentName:"p"},"url"),", which optionally ends with a name and version with the following format: ",(0,r.kt)("inlineCode",{parentName:"p"},"{NAME}/v{MAJOR}.{MINOR}"),"."),(0,r.kt)("p",null,"By default, external types should be namespaced (prefixed with ",(0,r.kt)("inlineCode",{parentName:"p"},"<namespace>__"),", e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"key")," directive should be namespaced as ",(0,r.kt)("inlineCode",{parentName:"p"},"federation__key"),") unless they are explicitly imported.\n",(0,r.kt)("inlineCode",{parentName:"p"},"graphql-kotlin")," automatically imports ALL federation directives to avoid the need for namespacing."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'@LinkDirective(url = "https://myspecs.company.dev/foo/v1.0", imports = ["@foo", "bar"])\nclass MySchema\n')),(0,r.kt)("p",null,"This will generate following schema:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'schema @link(import : ["@foo", "bar"], url : "https://myspecs.company.dev/foo/v1.0") {\n    query: Query\n}\n')),(0,r.kt)("admonition",{type:"danger"},(0,r.kt)("p",{parentName:"admonition"},"We currently DO NOT support full ",(0,r.kt)("inlineCode",{parentName:"p"},"@link")," directive capability as it requires support for namespacing and renaming imports. This functionality may be added in the future releases. See\n",(0,r.kt)("a",{parentName:"p",href:"https://specs.apollo.dev/link/v1.0"},"@link specification")," for details.")),(0,r.kt)("h2",{id:"override-directive"},(0,r.kt)("inlineCode",{parentName:"h2"},"@override")," directive"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Only available in Federation v2.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"directive @override(from: String!) on FIELD_DEFINITION\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"@override")," directive is used to indicate that the current subgraph is taking responsibility for resolving the marked field away from the subgraph specified in the ",(0,r.kt)("inlineCode",{parentName:"p"},"from")," argument,\ni.e. it is used for migrating a field from one subgraph to another. Name of the subgraph to be overriden has to match the name of the subgraph that was used to publish their schema. See\n",(0,r.kt)("a",{parentName:"p",href:"https://www.apollographql.com/docs/rover/subgraphs/#publishing-a-subgraph-schema-to-apollo-studio"},"Publishing schema to Apollo Studio")," for additional details."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Only one subgraph can ",(0,r.kt)("inlineCode",{parentName:"p"},"@override")," any given field. If multiple subgraphs attempt to ",(0,r.kt)("inlineCode",{parentName:"p"},"@override")," the same field, a composition error occurs.")),(0,r.kt)("h4",{id:"example-3"},"Example"),(0,r.kt)("p",null,"Given ",(0,r.kt)("inlineCode",{parentName:"p"},"SubgraphA")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'type Product @key(fields: "id") {\n    id: String!\n    description: String!\n}\n')),(0,r.kt)("p",null,"We can override gateway ",(0,r.kt)("inlineCode",{parentName:"p"},"description")," field resolution to resolve it in the ",(0,r.kt)("inlineCode",{parentName:"p"},"SubgraphB")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'type Product @key(fields: "id") {\n    id: String!\n    name: String!\n    description: String! @override(from: "SubgraphA")\n}\n')),(0,r.kt)("h2",{id:"provides-directive"},(0,r.kt)("inlineCode",{parentName:"h2"},"@provides")," directive"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"# federation v1 definition\ndirective @provides(fields: _FieldSet!) on FIELD_DEFINITION\n\n# federation v2 definition\ndirective @provides(fields: FieldSet!) on FIELD_DEFINITION\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"@provides")," directive is a router optimization hint specifying field set that can be resolved locally at the given subgraph through this particular query path. This allows you to\nexpose only a subset of fields from the underlying entity type to be selectable from the federated schema without the need to call other subgraphs. Provided fields specified in the\ndirective field set should correspond to a valid field on the underlying GraphQL interface/object type. ",(0,r.kt)("inlineCode",{parentName:"p"},"@provides")," directive can only be used on fields returning entities."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Federation v2 does not require ",(0,r.kt)("inlineCode",{parentName:"p"},"@provides")," directive if field can ",(0,r.kt)("strong",{parentName:"p"},"always")," be resolved locally. ",(0,r.kt)("inlineCode",{parentName:"p"},"@provides")," should be omitted in this situation.")),(0,r.kt)("h4",{id:"example-1-1"},"Example 1:"),(0,r.kt)("p",null,"We might want to expose only name of the user that submitted a review."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'@KeyDirective(FieldSet("id"))\nclass Review(val id: String) {\n  @ProvidesDirective(FieldSet("name"))\n  fun user(): User = getUserByReviewId(id)\n}\n\n@KeyDirective(FieldSet("userId"))\nclass User(\n  val userId: String,\n  @ExternalDirective val name: String\n)\n')),(0,r.kt)("p",null,"will generate"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'type Review @key(fields : "id") {\n  id: String!\n  user: User! @provides(fields : "name")\n}\n\ntype User @key(fields : "userId") {\n  userId: String!\n  name: String! @external\n}\n')),(0,r.kt)("h4",{id:"example-2-1"},"Example 2:"),(0,r.kt)("p",null,"Within our service, one of the queries could resolve all fields locally while other requires resolution from other subgraph"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'type Query {\n  remoteResolution: Foo\n  localOnly: Foo @provides("baz")\n}\n\ntype Foo @key("id") {\n  id: ID!\n  bar: Bar\n  baz: Baz @external\n}\n')),(0,r.kt)("p",null,"In the example above, if user selects ",(0,r.kt)("inlineCode",{parentName:"p"},"baz")," field, it will be resolved locally from ",(0,r.kt)("inlineCode",{parentName:"p"},"localOnly")," query but will require another subgraph invocation from ",(0,r.kt)("inlineCode",{parentName:"p"},"remoteResolution")," query."),(0,r.kt)("h2",{id:"requires-directive"},(0,r.kt)("inlineCode",{parentName:"h2"},"@requires")," directive"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"# federation v1 definition\ndirective @requires(fields: _FieldSet!) on FIELD_DEFINITON\n\n# federation v2 definition\ndirective @requires(fields: FieldSet!) on FIELD_DEFINITON\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"@requires")," directive is used to specify external (provided by other subgraphs) entity fields that are needed to resolve target field. It is used to develop a query plan where\nthe required fields may not be needed by the client, but the service may need additional information from other subgraphs. Required fields specified in the directive field set should\ncorrespond to a valid field on the underlying GraphQL interface/object and should be instrumented with ",(0,r.kt)("inlineCode",{parentName:"p"},"@external")," directive."),(0,r.kt)("p",null,"All the leaf fields from the specified in the ",(0,r.kt)("inlineCode",{parentName:"p"},"@requires")," selection set have to be marked as ",(0,r.kt)("inlineCode",{parentName:"p"},"@external")," OR any of the parent fields on the path to the leaf is marked as ",(0,r.kt)("inlineCode",{parentName:"p"},"@external"),"."),(0,r.kt)("p",null,"Fields specified in the ",(0,r.kt)("inlineCode",{parentName:"p"},"@requires")," directive will only be specified in the queries that reference those fields. This is problematic for Kotlin as the non-nullable primitive properties\nhave to be initialized when they are declared. Simplest workaround for this problem is to initialize the underlying property to some default value (e.g. null) that will be used if\nit is not specified. This approach might become problematic though as it might be impossible to determine whether fields was initialized with the default value or the invalid/default\nvalue was provided by the federated query. Another potential workaround is to rely on delegation to initialize the property after the object gets created. This will ensure that exception\nwill be thrown if queries attempt to resolve fields that reference the uninitialized property."),(0,r.kt)("h4",{id:"example-4"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'@KeyDirective(FieldSet("id"))\nclass Product(val id: String) {\n  @ExternalDirective\n  var weight: Double by Delegates.notNull()\n\n  @RequiresDirective(FieldSet("weight"))\n  fun shippingCost(): String { ... }\n}\n')),(0,r.kt)("p",null,"will generate"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'type Product @key(fields : "id") {\n  id: String!\n  shippingCost: String! @requires(fields : "weight")\n  weight: Float! @external\n}\n')),(0,r.kt)("h2",{id:"shareable-directive"},(0,r.kt)("inlineCode",{parentName:"h2"},"@shareable")," directive"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Only available in Federation v2.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"directive @shareable repeatable on FIELD_DEFINITION | OBJECT\n")),(0,r.kt)("p",null,"Shareable directive indicates that given object and/or field can be resolved by multiple subgraphs. If an object is marked as ",(0,r.kt)("inlineCode",{parentName:"p"},"@shareable")," then all its fields are automatically shareable without the\nneed for explicitly marking them with ",(0,r.kt)("inlineCode",{parentName:"p"},"@shareable")," directive. All fields referenced from ",(0,r.kt)("inlineCode",{parentName:"p"},"@key")," directive are automatically shareable as well."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Objects/fields have to specify same shareability (i.e. ",(0,r.kt)("inlineCode",{parentName:"p"},"@shareable")," or not) mode across ALL subgraphs.")),(0,r.kt)("h4",{id:"example-5"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'type Product @key(fields: "id") {\n  id: ID!                           # shareable because id is a key field\n  name: String                      # non-shareable\n  description: String @shareable    # shareable\n}\n\ntype User @key(fields: "email") @shareable {\n  email: String                    # shareable because User is marked shareable\n  name: String                     # shareable because User is marked shareable\n}\n')),(0,r.kt)("h2",{id:"tag-directive"},(0,r.kt)("inlineCode",{parentName:"h2"},"@tag")," directive"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"directive @tag(name: String!) repeatable on FIELD_DEFINITION\n    | OBJECT\n    | INTERFACE\n    | UNION\n    | ARGUMENT_DEFINITION\n    | SCALAR\n    | ENUM\n    | ENUM_VALUE\n    | INPUT_OBJECT\n    | INPUT_FIELD_DEFINITION\n")),(0,r.kt)("p",null,"Tag directive allows users to annotate fields and types with additional metadata information. Used by ",(0,r.kt)("a",{parentName:"p",href:"https://www.apollographql.com/docs/studio/contracts/"},"Apollo Contracts")," to expose\ndifferent graph variants to different customers. See ",(0,r.kt)("a",{parentName:"p",href:"https://specs.apollo.dev/tag/v0.2/"},"@tag specification")," for details."),(0,r.kt)("h4",{id:"example-6"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'type Product @tag(name: "MyCustomTag") {\n    id: String!\n    name: String!\n}\n')),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Apollo Contracts behave slightly differently depending on which version of Apollo Federation your graph uses (1 or 2). See ",(0,r.kt)("a",{parentName:"p",href:"https://www.apollographql.com/docs/studio/contracts/#federation-1-limitations"},"documentation"),"\nfor details.")))}h.isMDXComponent=!0}}]);