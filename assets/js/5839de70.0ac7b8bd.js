"use strict";(self.webpackChunkgraphql_kotlin_docs=self.webpackChunkgraphql_kotlin_docs||[]).push([[9883],{5162:(e,n,a)=>{a.d(n,{Z:()=>i});var t=a(7294),l=a(6010);const r="tabItem_Ymn6";function i(e){var n=e.children,a=e.hidden,i=e.className;return t.createElement("div",{role:"tabpanel",className:(0,l.Z)(r,i),hidden:a},n)}},4866:(e,n,a)=>{a.d(n,{Z:()=>N});var t=a(7462),l=a(7294),r=a(6010),i=a(2466),o=a(6775),u=a(1980),s=a(7392),p=a(12);function c(e){return function(e){return l.Children.map(e,(function(e){if((0,l.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')}))}(e).map((function(e){var n=e.props;return{value:n.value,label:n.label,attributes:n.attributes,default:n.default}}))}function d(e){var n=e.values,a=e.children;return(0,l.useMemo)((function(){var e=null!=n?n:c(a);return function(e){var n=(0,s.l)(e,(function(e,n){return e.value===n.value}));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,a])}function m(e){var n=e.value;return e.tabValues.some((function(e){return e.value===n}))}function f(e){var n=e.queryString,a=void 0!==n&&n,t=e.groupId,r=(0,o.k6)(),i=function(e){var n=e.queryString,a=void 0!==n&&n,t=e.groupId;if("string"==typeof a)return a;if(!1===a)return null;if(!0===a&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:a,groupId:t});return[(0,u._X)(i),(0,l.useCallback)((function(e){if(i){var n=new URLSearchParams(r.location.search);n.set(i,e),r.replace(Object.assign({},r.location,{search:n.toString()}))}}),[i,r])]}function v(e){var n,a,t,r,i=e.defaultValue,o=e.queryString,u=void 0!==o&&o,s=e.groupId,c=d(e),v=(0,l.useState)((function(){return function(e){var n,a=e.defaultValue,t=e.tabValues;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(a){if(!m({value:a,tabValues:t}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+a+'" but none of its children has the corresponding value. Available values are: '+t.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return a}var l=null!=(n=t.find((function(e){return e.default})))?n:t[0];if(!l)throw new Error("Unexpected error: 0 tabValues");return l.value}({defaultValue:i,tabValues:c})})),h=v[0],k=v[1],g=f({queryString:u,groupId:s}),b=g[0],y=g[1],I=(n=function(e){return e?"docusaurus.tab."+e:null}({groupId:s}.groupId),a=(0,p.Nk)(n),t=a[0],r=a[1],[t,(0,l.useCallback)((function(e){n&&r.set(e)}),[n,r])]),N=I[0],S=I[1],w=function(){var e=null!=b?b:N;return m({value:e,tabValues:c})?e:null}();return(0,l.useLayoutEffect)((function(){w&&k(w)}),[w]),{selectedValue:h,selectValue:(0,l.useCallback)((function(e){if(!m({value:e,tabValues:c}))throw new Error("Can't select invalid tab value="+e);k(e),y(e),S(e)}),[y,S,c]),tabValues:c}}var h=a(2389);const k="tabList__CuJ",g="tabItem_LNqP";function b(e){var n=e.className,a=e.block,o=e.selectedValue,u=e.selectValue,s=e.tabValues,p=[],c=(0,i.o5)().blockElementScrollPositionUntilNextRender,d=function(e){var n=e.currentTarget,a=p.indexOf(n),t=s[a].value;t!==o&&(c(n),u(t))},m=function(e){var n,a=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":var t,l=p.indexOf(e.currentTarget)+1;a=null!=(t=p[l])?t:p[0];break;case"ArrowLeft":var r,i=p.indexOf(e.currentTarget)-1;a=null!=(r=p[i])?r:p[p.length-1]}null==(n=a)||n.focus()};return l.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":a},n)},s.map((function(e){var n=e.value,a=e.label,i=e.attributes;return l.createElement("li",(0,t.Z)({role:"tab",tabIndex:o===n?0:-1,"aria-selected":o===n,key:n,ref:function(e){return p.push(e)},onKeyDown:m,onClick:d},i,{className:(0,r.Z)("tabs__item",g,null==i?void 0:i.className,{"tabs__item--active":o===n})}),null!=a?a:n)})))}function y(e){var n=e.lazy,a=e.children,t=e.selectedValue;if(a=Array.isArray(a)?a:[a],n){var r=a.find((function(e){return e.props.value===t}));return r?(0,l.cloneElement)(r,{className:"margin-top--md"}):null}return l.createElement("div",{className:"margin-top--md"},a.map((function(e,n){return(0,l.cloneElement)(e,{key:n,hidden:e.props.value!==t})})))}function I(e){var n=v(e);return l.createElement("div",{className:(0,r.Z)("tabs-container",k)},l.createElement(b,(0,t.Z)({},e,n)),l.createElement(y,(0,t.Z)({},e,n)))}function N(e){var n=(0,h.Z)();return l.createElement(I,(0,t.Z)({key:String(n)},e))}},9969:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>p,default:()=>v,frontMatter:()=>s,metadata:()=>c,toc:()=>m});var t=a(7462),l=a(3366),r=(a(7294),a(3905)),i=(a(8561),a(4866)),o=a(5162),u=["components"],s={id:"client-features",title:"Client Features"},p=void 0,c={unversionedId:"client/client-features",id:"version-5.x.x/client/client-features",title:"Client Features",description:"Jackson and Kotlinx Serialization Support",source:"@site/versioned_docs/version-5.x.x/client/client-features.mdx",sourceDirName:"client",slug:"/client/client-features",permalink:"/graphql-kotlin/docs/5.x.x/client/client-features",draft:!1,editUrl:"https://github.com/ExpediaGroup/graphql-kotlin/tree/master/website/versioned_docs/version-5.x.x/client/client-features.mdx",tags:[],version:"5.x.x",lastUpdatedBy:"Dariusz Kuc",lastUpdatedAt:1675875061,formattedLastUpdatedAt:"Feb 8, 2023",frontMatter:{id:"client-features",title:"Client Features"},sidebar:"version-5.x.x/docs",previous:{title:"Client Overview",permalink:"/graphql-kotlin/docs/5.x.x/client/client-overview"},next:{title:"Client Customization",permalink:"/graphql-kotlin/docs/5.x.x/client/client-customization"}},d={},m=[{value:"Jackson and Kotlinx Serialization Support",id:"jackson-and-kotlinx-serialization-support",level:2},{value:"Polymorphic Types Support",id:"polymorphic-types-support",level:2},{value:"Default Enum Values",id:"default-enum-values",level:2},{value:"Auto Generated Documentation",id:"auto-generated-documentation",level:2},{value:"Native Support for Coroutines",id:"native-support-for-coroutines",level:2},{value:"Batch Operation Support",id:"batch-operation-support",level:2},{value:"Optional Input Support",id:"optional-input-support",level:2}],f={toc:m};function v(e){var n=e.components,a=(0,l.Z)(e,u);return(0,r.kt)("wrapper",(0,t.Z)({},f,a,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"jackson-and-kotlinx-serialization-support"},"Jackson and Kotlinx Serialization Support"),(0,r.kt)("p",null,"GraphQL Kotlin supports generation of client data models that are compatible with both ",(0,r.kt)("inlineCode",{parentName:"p"},"Jackson")," (default) and ",(0,r.kt)("inlineCode",{parentName:"p"},"kotlinx.serialization"),"\nformats. Build plugins and ",(0,r.kt)("inlineCode",{parentName:"p"},"graphql-kotlin-spring-client")," default to use ",(0,r.kt)("inlineCode",{parentName:"p"},"Jackson")," whereas ",(0,r.kt)("inlineCode",{parentName:"p"},"graphql-kotlin-ktor-client"),"\ndefaults to ",(0,r.kt)("inlineCode",{parentName:"p"},"kotlinx.serialization"),"."),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"/graphql-kotlin/docs/5.x.x/client/client-serialization"},"client serialization documentation")," for additional details."),(0,r.kt)("h2",{id:"polymorphic-types-support"},"Polymorphic Types Support"),(0,r.kt)("p",null,"GraphQL supports polymorphic types through unions and interfaces which can be represented in Kotlin as marker and\nregular interfaces. In order to ensure generated objects are not empty, GraphQL queries referencing polymorphic types\nhave to ",(0,r.kt)("strong",{parentName:"p"},"explicitly specify all implementations"),". Polymorphic queries also have to explicitly request ",(0,r.kt)("inlineCode",{parentName:"p"},"__typename"),"\nfield so it can be used to Jackson correctly distinguish between different implementations."),(0,r.kt)("p",null,"Given example schema"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"type Query {\n  interfaceQuery: BasicInterface!\n}\n\ninterface BasicInterface {\n  id: Int!\n  name: String!\n}\n\ntype FirstInterfaceImplementation implements BasicInterface {\n  id: Int!\n  intValue: Int!\n  name: String!\n}\n\ntype SecondInterfaceImplementation implements BasicInterface {\n  floatValue: Float!\n  id: Int!\n  name: String!\n}\n")),(0,r.kt)("p",null,"We can query interface field as"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"query PolymorphicQuery {\n  interfaceQuery {\n    __typename\n    id\n    name\n    ... on FirstInterfaceImplementation {\n      intValue\n    }\n    ... on SecondInterfaceImplementation {\n      floatValue\n    }\n  }\n}\n")),(0,r.kt)("p",null,"Which will generate following data models"),(0,r.kt)(i.Z,{defaultValue:"jackson",values:[{label:"Jackson",value:"jackson"},{label:"kotlinx.serialization",value:"kotlinx"}],mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"jackson",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'@Generated\n@JsonTypeInfo(\n  use = JsonTypeInfo.Id.NAME,\n  include = JsonTypeInfo.As.PROPERTY,\n  property = "__typename"\n)\n@JsonSubTypes(value = [com.fasterxml.jackson.annotation.JsonSubTypes.Type(value =\n    FirstInterfaceImplementation::class,\n    name="FirstInterfaceImplementation"),com.fasterxml.jackson.annotation.JsonSubTypes.Type(value\n    = SecondInterfaceImplementation::class, name="SecondInterfaceImplementation")])\ninterface BasicInterface {\n  abstract val id: Int\n  abstract val name: String\n}\n\n@Generated\ndata class FirstInterfaceImplementation(\n  override val id: Int,\n  override val name: String,\n  val intValue: Int\n) : BasicInterface\n\n@Generated\ndata class SecondInterfaceImplementation(\n  override val id: Int,\n  override val name: String,\n  val floatValue: Float\n) : BasicInterface\n'))),(0,r.kt)(o.Z,{value:"kotlinx",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'@Generated\n@Serializable\nsealed class BasicInterface {\n  abstract val id: Int\n  abstract val name: String\n}\n\n@Generated\n@Serializable\n@SerialName(value = "FirstInterfaceImplementation")\ndata class FirstInterfaceImplementation(\n  override val id: Int,\n  override val name: String,\n  val intValue: Int\n) : BasicInterface()\n\n@Generated\n@Serializable\n@SerialName(value = "SecondInterfaceImplementation")\ndata class SecondInterfaceImplementation(\n  override val id: Int,\n  override val name: String,\n  val floatValue: Float\n) : BasicInterface()\n')))),(0,r.kt)("h2",{id:"default-enum-values"},"Default Enum Values"),(0,r.kt)("p",null,"Enums represent predefined set of values. Adding additional enum values could be a potentially breaking change as your\nclients may not be able to process it. GraphQL Kotlin Client automatically adds default ",(0,r.kt)("inlineCode",{parentName:"p"},"__UNKNOWN_VALUE")," to all generated\nenums as a catch all safeguard for handling new enum values."),(0,r.kt)("h2",{id:"auto-generated-documentation"},"Auto Generated Documentation"),(0,r.kt)("p",null,"GraphQL Kotlin build plugins automatically pull in GraphQL descriptions of the queried fields from the target schema and\nadd it as KDoc to corresponding data models."),(0,r.kt)("p",null,"Given simple GraphQL object definition"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'"Some basic description"\ntype BasicObject {\n  "Unique identifier"\n  id: Int!\n  "Object name"\n  name: String!\n}\n')),(0,r.kt)("p",null,"Will result in a corresponding auto generated data class"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"/**\n * Some basic description\n */\n @Generated\ndata class BasicObject(\n  /**\n   * Unique identifier\n   */\n  val id: Int,\n  /**\n   * Object name\n   */\n  val name: String\n)\n")),(0,r.kt)("h2",{id:"native-support-for-coroutines"},"Native Support for Coroutines"),(0,r.kt)("p",null,"GraphQL Kotlin Client is a generic interface that exposes ",(0,r.kt)("inlineCode",{parentName:"p"},"execute")," methods that will suspend your GraphQL operation until\nit gets a response back without blocking the underlying thread. Reference Ktor and Spring WebClient based implementations\noffer fully asynchronous communication through Kotlin coroutines. In order to fetch data asynchronously you should wrap\nyour client execution in ",(0,r.kt)("inlineCode",{parentName:"p"},"launch")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"async")," coroutine builder and explicitly ",(0,r.kt)("inlineCode",{parentName:"p"},"await")," for their results."),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"https://kotlinlang.org/docs/reference/coroutines-overview.html"},"Kotlin coroutines documentation")," for additional details."),(0,r.kt)("h2",{id:"batch-operation-support"},"Batch Operation Support"),(0,r.kt)("p",null,"GraphQL Kotlin Clients provide out of the box support for batching multiple client operations into a single GraphQL request.\nBatch requests are sent as an array of individual GraphQL requests and clients expect the server to respond with a corresponding\narray of GraphQL responses. Each response is then deserialized to a corresponding result type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val client = GraphQLKtorClient(url = URL("http://localhost:8080/graphql"))\nval firstQuery = FirstQuery(variables = FirstQuery.Variables(foo = "bar"))\nval secondQuery = SecondQuery(variables = SecondQuery.Variables(foo = "baz"))\n\nval results: List<GraphQLResponse<*>> = client.execute(listOf(firstQuery, secondQuery))\n')),(0,r.kt)("h2",{id:"optional-input-support"},"Optional Input Support"),(0,r.kt)("p",null,"In the GraphQL world, input types can be optional which means that the client can specify a value, specify a ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," value\nOR don't specify any value. This is in contrast with the JVM world where objects can either have some specific value or\ndon't have any value (i.e. are ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),"). By default, GraphQL Kotlin Client treats ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," Kotlin values as unspecified, which\nmeans they will skip all ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," values when serializing the request, e.g. given following query"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"query OptionalInputQuery($optionalValue: String) {\n  optional(value: $optionalValue)\n")),(0,r.kt)("p",null,"GraphQL Kotlin plugins will generate corresponding POJO that defines ",(0,r.kt)("inlineCode",{parentName:"p"},"Variables")," as"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"public data class Variables(\n  public val optionalValue: String? = null\n)\n")),(0,r.kt)("p",null,"Regardless whether we specify ",(0,r.kt)("inlineCode",{parentName:"p"},"optionalValue")," as ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," or rely on the default value, this field won't be serialized,\ni.e. variables will be serialized as an empty JSON object ",(0,r.kt)("inlineCode",{parentName:"p"},"{}"),"."),(0,r.kt)("p",null,"By specifying ",(0,r.kt)("inlineCode",{parentName:"p"},"useOptionalInputWrapper = true")," plugin configuration option, we can opt-in to a behavior that supports\nthree states - defined, ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," or undefined. Generated code will then use ",(0,r.kt)("inlineCode",{parentName:"p"},"OptionalInput")," wrapper to represent those states.\nSee ",(0,r.kt)("a",{parentName:"p",href:"../plugins/gradle-plugin-tasks"},"Gradle")," and ",(0,r.kt)("a",{parentName:"p",href:"../plugins/maven-plugin-goals"},"Maven")," plugin for configuration details."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'public data class Variables(\n  public val optionalValue: OptionalInput<String> = OptionalInput.Undefined\n)\n\n// usage\n// - same behavior as default null, serialized as {}\nval undefinedVariables = Variables(optionalValue = OptionalInput.Undefined)\n\n// - serialized as {"optionalValue": null}\nval nullVariables = Variables(optionalValue = OptionalInput.Defined(null))\n\n// - serialized as {"optionalValue": "foo"}\nval definedVariables = Variables(optionalValue = OptionalInput.Defined("foo")\n')))}v.isMDXComponent=!0}}]);